---
title: "Time Profile Plot Vignette"
author: "OSPSuiteR 2019"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{time-profile-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
The aim of this vignette is to illustrate the workflow for producing time profile plots using the `tlf`-Library.

## Libraries

The main purpose of the `tlf`-library is to standardized the production of `ggplot` objects from data output by `OSPSuiteR`. As such, `tlf`-library requires that the `ggplot2` package be installed.

```{r setup}
# The update of the tlf library with document needs to be called in the vignette
# Otherwise, the library is not up to date to be knitted
devtools::document()
library(tlf)
library(ggplot2)
```

The suggested workflow for performing any kind of plot with the `tlf`-library is illustrated in the figure below. 


## `tlf` workflow
```{r, out.width="100%", include=TRUE, fig.align="center", echo=FALSE}
knitr::include_graphics("workflowSlide.png")
```

The standard workflow then proceeds as follows:

**Step 0 - Data gathering.** Gather the data into tidy dataframe format.

**Step 1 - Data pre-processing** Pre-process the data using `AggregationSummary` class.

**Step 2 - Data grouping** Use the `Groupings` class to specify groupings according to which the data will be captioned in figure legends.

**Step 3 - Data mapping.** Use the `DataMapping` class to select the independent and dependent variables of the processed data as well as the aesthetics that will be used to differentiate between the groupings of the data that were specified in step 2.

**Step 4 - Plot configuration** Set the `PlotConfiguration` object which will define settings of the plot such as axis labeling, font sizes and watermarks.

**Step 5  - Plot generation** Create a `ggplot` object from the above classes using the dedicated plotting function.

Steps 1, 2, 3 and 4 are not mandatory.  If not implemented, `tlf`-libray uses default settings in lieu of the objects that are otherwise created in these optional steps. In addition, the `PlotConfiguration` object and the `DataMapping` object can be created independently. 

### A minimal example
Before presentation of the full functionality of `tlf` classes, the following minimal example of a time profile plot will demonstrate the workflow for producing a `ggplot` image using Steps 0, 2, 3 and 5.

**Example Step 0:**
The data to be plotted in `tlf` is assumed to be in R dataframe format.  An example such dataframe is the following, which contains time profile concentration data for two individuals.  Each individual is allocated a unqiue indentifier in the column *IndividualID*.
```{r, results='asis'}
minimalDataFrame <- data.frame("Time"=c(0,1,2,0,1,2),
                               "IndividualID"=as.factor(c(1,1,1,2,2,2)),
                               "Concentration"=c(3,4,5,4,5,6))
pander::pandoc.table(minimalDataFrame)
```


**Example Step 2:**
In this step, groupings of the data are specified.  In this simple example, each individual's measurements are to be plotted using different linetypes.  A `Grouping` object is therefore created that specifies that a graph with a different *linetype* is to be used to plot the points for each unique value of the *IndividualID* column. 
```{r, results='asis'}
minimalGrouping <- Groupings$new( linetype = "IndividualID" )
```
The construction of more detailed groupings is discussed in the Groupings section below.

**Example Step 3:**
Here, the independent and dependent variables of the plot and the plot groupings are specified using a `TimeProfileDataMapping` object, which is a subclass of the DataMapping class specifically aimed at producing time profile plots.  The constructor of this class identifies the *Time* column of the dataframe as the time axis, the *Concentration* column of the dataframe as the vertical axis, and `minimalGrouping`, which was defined in the earlier step, as the grouping object to use.  
```{r, results='asis'}
minimalDataMapping <-TimeProfileDataMapping$new(x = "Time",
                                                y = "Concentration",
                                                groupings = minimalGrouping)
```

**Example Step 5:**
In the final step of this example, a `ggplot` object called `timeProfilePlot` is created using the `plotTimeProfile` function:  
```{r, fig.height=5, fig.width=7.5}
timeProfilePlot<-plotTimeProfile(data = minimalDataFrame , dataMapping = minimalDataMapping)
show(timeProfilePlot)
```

# 0. Data gathering

## The dataset

In the sequel, the data that will be used for the time profile plot is the following `data.frame` variable named `timeProfileDataFrame`:

```{r, results='asis'}
# Data frame printed in a nice markdown table:
pander::pandoc.table(timeProfileDataFrame[,c("IndividualID", "Time", "Gender", "Age", "Simulated")], justify='right', round=2)
```

The workflow assumes that the data to be plotted has been gathered in the form of a [*tidy*](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) dataframe.  In a tidy format dataframe, each *measurement*, such as a simulation result or experimental observation, is described entirely in one row.  The columns of the dataframe are limited to no more than the *independent variable* columns of the measurement (in this example, *Time* and *IndividualID*) and the *dependent variable* columns (in this case *Simulated*), which hold the value of the measurement.  Since no additional columns are allowed, two dependent variables that have differing sets of independent variables should each have their own tidy dataframes.

## MetaData

A `metaData` variable associated with the data can be used to define additional information such as the `dimension` and `units` of each column in the `data.frame`. The lower limit of quantitiation of time profile data can also be stored in the `metaData`. 




```{r, results='asis'}
timeProfileMetaData <- list(Time = list(unit = "min", dimension = "Time"), 
                            Simulated = list(unit = "ug/mL", dimension = "Concentration"))
```


# 1. Data pre-processing

The `R6` class `AggregationSummary` automates the computation of multiple summary statistics of the raw data that is output by **Step 0**.  The output of this optional data pre-processing step is a list of tidy dataframes, one for each summary statistic.  Each dataframe in the list is of the same format as that output by **Step 0**.  These dataframes can be input into the subsequent steps of the workflow.  The user also has the option of generating `metaData` for each of these dataframes.

To illustrate the function of this class for the example of the dataframe `timeProfileDataFrame`, suppose that for each timepoint in the *Time* column, the *minimum* and the *mean* value of the *Simulated* column is to be computed for each gender in the *Gender* column.  The `AggregationSummary` class works in three steps:

1. Three sets of columns are selected from the input dataframe `data`: an *independent variable* set called `xColumnNames` (in this case, the *Time* column in `timeProfileDataFrame`),  a *grouping variables* set called `groupingColumnNames` (the *Gender* column in `timeProfileDataFrame`) and a *dependent variables* set called `yColumnNames` (the *Simulated* column in `timeProfileDataFrame`).

2. For each value of the independent variable `xColumnNames`, the rows of the dataframe are aggregated into groups defined by unique combinations of the elements in the grouping variable columns `groupingColumnNames`.

3. Summary statistics (in this case, the minimum and the mean) for the `yColumnNames` variables in each group are evaluated.  The functions for computing the the summary statistics are specified when initializing an `AggregationSummary`, via `aggregationFunctionsVector`.  User-specified descriptive names of these functions are supplied via the vector of strings named `aggregationFunctionNames`.  The units and dimensions of the outputs of these functions are supplied via the vectors of strings named `aggregationUnitsVector` and `aggregationDimensionsVector`, respectively. 

For this example, the `AggregationSummary` object `aggSummary` is instatiated as follows:

```{r, results='asis'}
aggSummary <- AggregationSummary$new(data = timeProfileDataFrame , 
                                     metaData = timeProfileMetaData,
                                     xColumnNames = "Time",
                                     groupingColumnNames = "Gender",
                                     yColumnNames = "Simulated",
                                     aggregationFunctionsVector = c(min,mean),
                                     aggregationFunctionNames =c("SimulatedMin",
                                                                 "SimulatedMean"),
                                     aggregationUnitsVector = c("mg/L","mg/L"),
                                     aggregationDimensionsVector = c("Concentration",
                                                                     "Concentration"))


```

The dataframes that hold the summary statistics of the aggregated rows are stored in a list named `dfHelper`, which is a property of the resulting `aggSummary` object.  Since two functions (`min` and `mean`) were specified in `aggregationFunctionsVector`, the list `aggSummary$dfHelper` holds two dataframes, `aggSummary$dfHelper$SimulatedMin` and `aggSummary$dfHelper$SimulatedMean`.

```{r, results='asis'}
pander::pandoc.table(aggSummary$dfHelper$SimulatedMin)
```

```{r, results='asis'}
pander::pandoc.table(aggSummary$dfHelper$SimulatedMean)
```

The `metaData` of the columns of the resulting dataframes are each lists that are stored together in a list named `aggSummary$metaDataHelper`.  The two `metaData` lists in `aggSummary$metaDataHelper` are  `aggSummary$metaDataHelper$SimulatedMin` and `aggSummary$dfHelper$SimulatedMean`.  The contents of the list `aggSummary$metaDataHelper$SimulatedMean` are:

``` 
  * **Time**:

      * **unit**: min
      * **dimension**: Time

  * **Gender**:

      * **unit**:
      * **dimension**:

  * **SimulatedMean**:

      * **unit**: mg/L
      * **dimension**: Concentration 
``` 
 
When initializing an `AggregationSummary`, the `yColumnNames` is the name of the variable to be aggregated, `groupingColumnNames` are the variables that will group the data for the aggragtion , `aggregationFunctionsVector` is a vector of functions to be used during the aggregation and `aggregationFunctionNames` the name of the associated variables within the output `data.frame` of the helper.

 

, 2) thIn an aggregation summary` class are: 1) a dataframe `data`, 2) th


The following example illustrates the outcome of the helper:
```{r, results='asis'}
hlp <- TimeProfileHelper$new(data = timeProfileDataFrame,
                             timeColumnName = "Time",
                             groupingColumnNames = c("Population"),
                             valuesColumnNames = "Simulated",
                             aggregationFunctionsVector = c(mean, min, max),
                             aggregationFunctionNames =  c("SimulatedMean", "SimulatedMin", "SimulatedMax"))


pander::pandoc.table(hlp$dfHelper, round=2)
```
 

## Groupings


The `R6` class `Groupings` can help you process some of the data and define grouping variables which are often used by `ggplot` to split the data and create subsequent legend and captions.

This class defines `GroupMapping` for any aesthetic parameter of `ggplot`.
Two types of input can be submitted to `GroupMapping` a `character` type indicating the name of the variables to be used for grouping; and a `data.frame` type directly linking the grouping variables to the grouping variable at the last column of the data.frame.
The optional input `label` indicates the name of the grouping variable resulting from the mapping.

Below are use cases of the `GroupMapping`:

```{r, results='asis'}
# Grouping by variable names:
grouping1 <- GroupMapping$new(c("Compound", "Dose"))

# Grouping by variable names and overwriting the default label:
grouping2 <- GroupMapping$new(c("Compound", "Dose"), label = "Compound & Dose")

# Grouping using a data.frame:
mappingDataFrame <- data.frame(IndividualID = c(1,2,3,4) , 
                                    PatientName = c("Paul", "John", "George", "Ringo"))

grouping3 <- GroupMapping$new(mappingDataFrame)

# Aplly the mapping to get the grouping captions:
groupingsDataFrame <- data.frame(
  timeProfileDataFrame$IndividualID,
  timeProfileDataFrame$Dose,
  timeProfileDataFrame$Compound,
  grouping1$getCaptions(timeProfileDataFrame),
  grouping2$getCaptions(timeProfileDataFrame),
  grouping3$getCaptions(timeProfileDataFrame))

names(groupingsDataFrame) <- c("IndividualID", "Dose", "Compound",
                               grouping1$label, grouping2$label, grouping3$label)

# Show results for all groupings:
pander::pandoc.table(groupingsDataFrame)
```

Then, this association can be used in `dataMapping` of type `XYGDataMapping` through the class `Groupings` which will map any `GroupMapping` to an aesthetic parameter such as `color` or `linetype`. `Groupings` can use directly the input of `GroupMapping` to improve efficiency.

```{r, results='asis'}
# Map groups to aesthtic properties
groups <- Groupings$new(color = c("Compound", "Dose"),
                        shape = mappingDataFrame)

# Aplly the mapping to get the grouping captions:
dataMapping <- XYGDataMapping$new(x="Time", y="Simulated", groupings = groups)

# Show results for all groupings:
pander::pandoc.table(dataMapping$getMapData(data = timeProfileDataFrame,
                                            metaData = timeProfileMetaData))
```



# 3. dataMapping

The `R6` class `TimeProfileDataMapping` is dedicated to map `x`, `y` and `groupings` for time profile plots.
Its inner function `getMapData` creates an output `data.frame` mapping the `x`, `y` and `groupings` of any input `data`.

The basic example is to map only `x` and `y`:
```{r, results='asis'}
tpMapping <- TimeProfileDataMapping$new(x="Time", y="Simulated")
pander::pandoc.table(tpMapping$getMapData(data = timeProfileDataFrame,
                                          metaData = timeProfileMetaData))
```

A more complex example is to add `groupings` to `x` and `y`:
```{r, results='asis'}
# Re-use the variable groups previously defined
tpMapping <- TimeProfileDataMapping$new(x="Time", y="Simulated", 
                                        groupings = groups)

pander::pandoc.table(tpMapping$getMapData(data = timeProfileDataFrame,
                                          metaData = timeProfileMetaData))
```

Specific to time profiles, `TimeProfileDataMapping` allows the mapping of `yMin` and `yMax`.
These parameters are expected in case error bars are needed or in case a time range profile is needed.
If only `yMin` and `yMax` are input in the mapping `y` being undefined or `NULL`, the expected profile is a range.
If `y`, `yMin` and `yMax` are input in the mapping, the expected profile is an error bar.

```{r, results='asis'}
# Use the helper to aggregate min and max values

hlp <- TimeProfileHelper$new(data = timeProfileDataFrame,
                             timeColumnName = "Time",
                             groupingColumnNames = c("Population"),
                             valuesColumnNames = "Simulated",
                             aggregationFunctionsVector = c(mean, min, max),
                             aggregationFunctionNames =  c("SimulatedMean", "SimulatedMin", "SimulatedMax"))

# Define Mapping with yMin and yMax
tpMapping <- TimeProfileDataMapping$new(x="Time", y="SimulatedMean", 
                                        yMin = "SimulatedMin", yMax = "SimulatedMax")

pander::pandoc.table(tpMapping$getMapData(data = hlp$dfHelper,
                                          metaData = hlp$metaDataHelper))
```


# 4. plotConfiguration

## Theme

A `Theme` class can be used to standardize plot configurations. So far, 4 predefined themes are available: `defaultTheme`, `tlfTheme`, `bwTheme` and `bigTheme`. The function `useTheme` set a theme as the current theme of the environment. As for instance: `useTheme(tlfTheme)`.

## Plot Configuration for time profiles

The `R6` class `TimeProfilePlotConfiguration` is dedicated to set the configuration of time profile plots. It inherits from the `R6` class `PlotConfiguration` and as such it is split into 4 subclasses:

- `LabelConfiguration` from which any `PlotConfiguration` inherits and that defines the size and fonts of the labels (title, xlabel, ...)
- `XAxisConfiguration` that defines the limits, scale and ticks of the x-axis
- `YAxisConfiguration` that defines the limits, scale and ticks of the y-axis
- `LegendConfiguration` that defines the titles, captions and values for any aesthetic parameter (`color`, `linetype`,...)


The definition of the configuration can be performed as follows:
```{r}
config <- PlotConfiguration$new(title = "Title",
                      xlabel = "x-axis label", 
                      ylabel = "y-axis label", 
                      watermark = "background")

# Overall features of the configurtion
config

# Title and its configuration
config$title
config$title$font

# scale of x axis
config$xAxis$scale

```

Example for a time profile plot:
```{r}
tpConfig <- TimeProfilePlotConfiguration$new()

# Overall features of the configurtion
tpConfig
```

Since the plot configuration is not a necessary input for the plot functions, it can use default values if not overwritten. Called within plot functions its default values use data, metaData and dataMapping as input to get a smarter configuration.

Below is an example for a time profile configuration using data, metaData and dataMapping:

```{r}
# Define the time profile mapping
tpMapping <- TimeProfileDataMapping$new(x="Time", y="Simulated")

# Define the time profile configuration using
# data, metaData and dataMapping
tpConfig <- TimeProfilePlotConfiguration$new(data = timeProfileDataFrame,
                                             metaData = timeProfileMetaData,
                                             dataMapping = tpMapping)

# Overall features of the configurtion
tpConfig
```

# 5. Examples

The function that creates ggplot objects for time profiles is `plotTimeProfile` whose input arguments are `data`, `metaData`, `dataMapping` and `plotConfiguration`.

## 5.1. Basic example of time profile plot

```{r, fig.height=5, fig.width=7.5}
# Map x and y of the plot
tpMapping <- TimeProfileDataMapping$new(x="Time", y="Simulated")

# Define the ggplot object
plotObject <- plotTimeProfile(data=timeProfileDataFrame, 
                              metaData = timeProfileMetaData,
                              dataMapping = tpMapping)
# Show plot
plotObject

```

You can notice that the plot presents almost error bars, this is due to the fact that the plot has more than 1 value per time point.

## 5.2. Workflow example of time profile plot using `TimeProfilePlotConfiguration`

```{r, fig.height=5, fig.width=7.5}
# Set current theme
useTheme(tlfTheme)

# Map x and y of the plot
tpMapping <- TimeProfileDataMapping$new(x="Time", y="Simulated")

# Overwrite plot configuration 
tpConfig <- TimeProfilePlotConfiguration$new(title = "New Plot",
                                             ylabel = "Simulated Results",
                                             data = timeProfileDataFrame,
                                             metaData = timeProfileMetaData,
                                             dataMapping = tpMapping)

# Define the ggplot object with updated configuration
plotObject <- plotTimeProfile(data=timeProfileDataFrame, 
                              metaData = timeProfileMetaData,
                              dataMapping = tpMapping, 
                              plotConfiguration = tpConfig)
# Show plot
plotObject

```

## 5.3. Workflow example of time profile plot using `TimeProfileDataMapping` with `Groupings`

```{r, fig.height=5, fig.width=7.5}
# Map x, y and groups of the plot
groups <- Groupings$new(color = "IndividualID", 
                        linetype = "Population")

tpMapping <- TimeProfileDataMapping$new(x = "Time", 
                                        y = "Simulated", 
                                        groupings = groups)

# Define the ggplot object
plotObject <- plotTimeProfile(data=timeProfileDataFrame,
                           metaData = timeProfileMetaData,
                           dataMapping = tpMapping)

# Show plot
plotObject

```

## 5.4. Workflow example of time profile plot using `TimeProfileDataMapping` with `Groupings` as data.frame

```{r, fig.height=5, fig.width=7.5}
# data.frame associating grouping to Individual ID with their captions
groupingIndividualsDf <- data.frame(IndividualID = c(1,2,3,4) , 
                                    "Name of Beatle" = c("Paul", "John", "George", "Ringo"))
# Define the grouping variable
groups = Groupings$new(color = groupingIndividualsDf)

# Map x, y and groups
tpMapping <- TimeProfileDataMapping$new(x = "Time",
                                        y = "Simulated",
                                        groupings = groups)

# Define the ggplot object
plotObject <- plotTimeProfile(data=timeProfileDataFrame,
                           metaData = timeProfileMetaData,
                           dataMapping = tpMapping)

# Show plot
plotObject

```

## 5.5. Workflow example of time profile plot using `TimeProfileDataMapping` with `Helper`

### 5.5.1. Plot aggregated mean value
```{r, fig.height=5, fig.width=7.5}
# Define aggregated values through helper
hlp <- TimeProfileHelper$new(data = timeProfileDataFrame,
                             timeColumnName = "Time",
                             groupingColumnNames = c("Population"),
                             valuesColumnNames = "Simulated",
                             aggregationFunctionsVector = c(mean, min, max),
                             aggregationFunctionNames =  c("SimulatedMean", "SimulatedMin", "SimulatedMax"))

# Map x and y
tpMappingMean <- TimeProfileDataMapping$new(x = "Time", 
                                            y = "SimulatedMean")
# Overwrite the plot configuration
tpConfig <-  TimeProfilePlotConfiguration$new(ylabel = "Simulated Results",
                                              xlabel = "Time")

# Define the ggplot object
meanPlot <- plotTimeProfile(data=hlp$dfHelper,
                            dataMapping = tpMappingMean,
                            plotConfiguration = tpConfig)
# Show plot
meanPlot
```

### 5.5.2. Plot aggregated mean value by population

```{r, fig.height=5, fig.width=7.5}
# Map x, y and groupings
tpMappingMean <- TimeProfileDataMapping$new(x = "Time", 
                                            y = "SimulatedMean",
                                            groupings = Groupings$new(color = "Population"))

# Overwrite the plot configuration
tpConfig <-  TimeProfilePlotConfiguration$new(ylabel = "Simulated Results",
                                              xlabel = "Time",
                                              data=hlp$dfHelper,
                                              dataMapping = tpMappingMean)

# Define the ggplot object
meanPlot <- plotTimeProfile(data=hlp$dfHelper,
                            dataMapping = tpMappingMean,
                            plotConfiguration = tpConfig)
# Show plot
meanPlot
```

### 5.5.3. Plot aggregated min and max values

```{r, fig.height=5, fig.width=7.5}
# Map x, yMin and yMax
tpMappingRange <- TimeProfileDataMapping$new(x = "Time", 
                                             yMin = "SimulatedMin", 
                                             yMax = "SimulatedMax")

# Overwrite the plot configuration
tpConfig <-  TimeProfilePlotConfiguration$new(ylabel = "Simulated Results",
                                              xlabel = "Time",
                                              data=hlp$dfHelper,
                                              dataMapping = tpMappingRange)

# Define the ggplot object
rangePlot <- plotTimeProfile(data=hlp$dfHelper,
                            dataMapping = tpMappingRange)

# Show plot
rangePlot
```

### 5.5.4. Plot aggregated min and max values by population

```{r, fig.height=5, fig.width=7.5}
# Map x, yMin and yMax
tpMappingRange <- TimeProfileDataMapping$new(x = "Time", 
                                             yMin = "SimulatedMin", 
                                             yMax = "SimulatedMax",
                                             groupings = Groupings$new(fill = "Population"))

# Overwrite the plot configuration
tpConfig <-  TimeProfilePlotConfiguration$new(ylabel = "Simulated Results",
                                              xlabel = "Time",
                                              data=hlp$dfHelper,
                                              dataMapping = tpMappingRange)

# Define the ggplot object
rangePlot <- plotTimeProfile(data=hlp$dfHelper,
                            dataMapping = tpMappingRange,
                            plotConfiguration = tpConfig)

# Show plot
rangePlot
```

### 5.5.5. Plot aggregated mean, min, max values by population
```{r, fig.height=5, fig.width=7.5}
# Map x, y, yMin and yMax
tpMappingErrorBar <- TimeProfileDataMapping$new(x = "Time", 
                                                y = "SimulatedMean",
                                                yMin = "SimulatedMin", 
                                                yMax = "SimulatedMax",
                                                groupings = Groupings$new(color = "Population"))

# Overwrite the plot configuration
tpConfig <-  TimeProfilePlotConfiguration$new(ylabel = "Simulated Results",
                                              xlabel = "Time",
                                              data=hlp$dfHelper,
                                              dataMapping = tpMappingErrorBar)

# Define the ggplot object
errorBarPlot <- plotTimeProfile(data=hlp$dfHelper,
                                dataMapping = tpMappingErrorBar,
                                plotConfiguration = tpConfig)

# Show plot
errorBarPlot

```
